import numpy as np
import matplotlib.pyplot as plt


class Hyperbole:
    """
    A class for constructing and visualizing a hyperbola of the second order in a Cartesian coordinate system.
    """

    def __init__(self, a, b, num_points=1000, x_offset=0, y_offset=0, visible_asymptote=False):
        self.Y_rot = None
        self.X_rot = None
        self.a = a  # The parameter of the hyperbola
        self.b = b  # The parameter of the hyperbola
        self.num_points = num_points  # Number of points in the grid
        self.x_offset = x_offset  # Horizontal offset
        self.y_offset = y_offset  # Vertical offset
        self.visible_asymptote = visible_asymptote  # Flag to show asymptotes

        # Create coordinate grids
        self.x = np.linspace(- 3 * a , 3 * a, num_points)
        self.y = np.linspace(-4 * b, 4 * b, num_points)
        self.X, self.Y = np.meshgrid(self.x, self.y)

    def calculate_Z(self):
        """
        Computes the values of Z based on the equation for the hyperbola.

        Returns:
            np.ndarray: A 2D array of computed Z values for the coordinate grid.
        """
        Z = (self.X ** 2 / self.a**2) - (self.Y ** 2 / self.b**2) - 1  # Standard form of a hyperbola
        return Z

    def rotate(self, angle_deg):
        """
        Rotates the contour plot by a specified angle.

        Args:
            angle_deg (float): The angle in degrees to rotate the plot.
        """
        angle_rad = np.deg2rad(angle_deg)  # Convert angle to radians
        rotation_matrix = np.array([[np.cos(angle_rad), -np.sin(angle_rad)],
                                    [np.sin(angle_rad), np.cos(angle_rad)]])  # Rotation matrix

        # Transform the X and Y coordinates
        points = np.vstack([self.X.ravel(), self.Y.ravel()])
        rotated_points = rotation_matrix @ points
        self.X_rot = rotated_points[0].reshape(self.X.shape)
        self.Y_rot = rotated_points[1].reshape(self.Y.shape)

        # Rotate the asymptote slopes
        slope_pos, slope_neg = self.find_asymptotes()
        self.slope_pos_rot, self.slope_neg_rot = self.rotate_slope(slope_pos, slope_neg, angle_rad)

    def rotate_slope(self, slope_pos, slope_neg, angle_rad):
        """
        Rotates the slopes of the asymptotes by the given angle.

        Args:
            slope_pos (float): The original positive slope of the asymptote.
            slope_neg (float): The original negative slope of the asymptote.
            angle_rad (float): The angle in radians by which to rotate the slopes.

        Returns:
            tuple: The new rotated slopes (positive and negative).
        """
        # Convert the slopes to angle form (tan⁻¹(slope)) and add the rotation angle
        angle_pos = np.arctan(slope_pos)
        angle_neg = np.arctan(slope_neg)

        angle_pos_rot = angle_pos + angle_rad
        angle_neg_rot = angle_neg + angle_rad

        # Convert back to slope form (tan of the rotated angles)
        slope_pos_rot = np.tan(angle_pos_rot)
        slope_neg_rot = np.tan(angle_neg_rot)

        return slope_pos_rot, slope_neg_rot

    def find_asymptotes(self):
        """
        Finds the asymptotes for the hyperbola.

        Returns:
            tuple: The slopes of the asymptotes (positive and negative).
        """
        return self.b / self.a, -self.b / self.a  # Asymptote slopes for a standard hyperbola

    def plot(self):
        """
        Generates a contour plot of the hyperbola.
        Displays the curve, coordinate axes, and optional asymptotes.
        """
        Z = self.calculate_Z()  # Compute Z values

        # Use rotated coordinates if rotation is applied
        X_plot = self.X_rot if hasattr(self, 'X_rot') else self.X
        Y_plot = self.Y_rot if hasattr(self, 'Y_rot') else self.Y

        # Create the plot
        plt.figure(figsize=(12, 8))
        plt.contour(X_plot, Y_plot, Z, levels=[0], colors='blue')  # Plot the contour for Z = 0

        # Add title and axis labels
        plt.title(f'Contour plot of the hyperbola (a={self.a}, b={self.b})')
        plt.xlabel('X-axis')
        plt.ylabel('Y-axis')

        # Add coordinate axes
        plt.axhline(0, color='black', linewidth=0.7)  # Horizontal axis
        plt.axvline(0, color='black', linewidth=0.7)  # Vertical axis

        # Add asymptotes if specified
        if self.visible_asymptote:
            # Asymptotes are lines y = m * x for the positive and negative slopes
            x_vals = np.linspace(-self.a * 5, self.a * 5, self.num_points)
            y_pos = self.slope_pos_rot * x_vals
            y_neg = self.slope_neg_rot * x_vals
            plt.plot(x_vals, y_pos, 'r--', label=f'Asymptote y = {self.slope_pos_rot:.2f}x')
            plt.plot(x_vals, y_neg, 'r--', label=f'Asymptote y = {self.slope_neg_rot:.2f}x')

        # Enable grid
        plt.grid(True)

        # Add legend if asymptotes are visible
        if self.visible_asymptote:
            plt.legend()

        # Set axis limits to compress the appearance
        plt.xlim(-self.a * 3 , self.a * 3 )  # Compress x-axis
        plt.ylim(-self.b * 1.5 , self.b * 1.5 )  # Compress y-axis

        # Adjust layout for better fit
        plt.tight_layout()

        # Display the plot
        plt.show()


